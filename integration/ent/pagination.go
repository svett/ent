// Code generated by entc, DO NOT EDIT.

package ent

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/jmoiron/sqlx/reflectx"
)

var mapper = reflectx.NewMapper("json")

// Predicate creates a predicate
type Predicate = func(s *sql.Selector)

// EQ applies an equal predicate
func EQ(field string, value interface{}) Predicate {
	return func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(field), value))
	}
}

// GT applies a greater than predicate
func GT(field string, value interface{}) Predicate {
	return func(s *sql.Selector) {
		s.Where(sql.GT(s.C(field), value))
	}
}

// LT applies a less than predicate
func LT(field string, value interface{}) Predicate {
	return func(s *sql.Selector) {
		s.Where(sql.LT(s.C(field), value))
	}
}

// And groups list of predicates with the AND operator between them.
func And(predicates ...Predicate) Predicate {
	return func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	}
}

// Or groups list of predicates with the OR operator between them.
func Or(predicates ...Predicate) Predicate {
	return func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	}
}

// CursorPosition represets a cursor position
type CursorPosition struct {
	Column    string
	Direction string
	Value     interface{}
}

// ProductCursor represents the cursor
type ProductCursor struct {
	positions []*CursorPosition
}

// DecodeCursor decodes a cursor from its base-64 string representation.
func DecodeProductCursor(order, token string) (*ProductCursor, error) {
	cursor := &ProductCursor{}

	if err := cursor.positionsAt(order); err != nil {
		return nil, err
	}

	if err := cursor.valuesAt(token); err != nil {
		return nil, err
	}

	return cursor, nil
}

// String returns a base-64 string representation of a cursor.
func (c *ProductCursor) String() string {
	count := len(c.positions)

	if count == 0 {
		return ""
	}

	values := make([]interface{}, count)

	for index, position := range c.positions {
		values[index] = position.Value
	}

	data, err := json.Marshal(values)
	if err != nil {
		panic(err)
	}

	return strings.TrimRight(base64.URLEncoding.EncodeToString(data), "=")
}

// Next returns the next cursor
func (c *ProductCursor) Next(input interface{}) *ProductCursor {
	var (
		next   = ProductCursor{}
		source = reflect.ValueOf(input)
	)

	//TODO: do not use reflection
	if source.Type().Kind() == reflect.Slice {
		if source.Len() == 0 {
			return &next
		}

		source = source.Index(source.Len() - 1)
	}

	for _, position := range c.positions {
		index := &CursorPosition{
			Column:    position.Column,
			Direction: position.Direction,
			Value:     mapper.FieldByName(source, position.Column).Interface(),
		}

		next.positions = append(next.positions, index)
	}

	return &next
}

func (c *ProductCursor) positionsAt(order string) error {
	const (
		separator = ","
		asc       = "+"
		desc      = "-"
	)

	for _, field := range strings.Split(order, separator) {
		field = strings.TrimSpace(field)

		if field == "" {
			continue
		}

		position := &CursorPosition{
			Column:    field,
			Direction: asc,
		}

		switch {
		case strings.HasPrefix(field, asc):
			position = &CursorPosition{
				Column:    field[1:],
				Direction: asc,
			}
		case strings.HasPrefix(field, desc):
			position = &CursorPosition{
				Column:    field[1:],
				Direction: desc,
			}
		}

		switch position.Column {
		case "id":
		case "title":
		case "created_at":
		case "updated_at":
		default:
			return fmt.Errorf("ent: unknown '%s' column", position.Column)
		}

		c.positions = append(c.positions, position)
	}

	return nil
}

func (c *ProductCursor) valuesAt(token string) error {
	values := []interface{}{}

	if token == "" {
		return nil
	}

	if n := len(token) % 4; n != 0 {
		token += strings.Repeat("=", 4-n)
	}

	data, err := base64.URLEncoding.DecodeString(token)
	if err != nil {
		return err
	}

	if err := json.Unmarshal(data, &values); err != nil {
		return err
	}

	for index, position := range c.positions {
		if index >= len(values) {
			return fmt.Errorf("ent: invalid pagination cursor")
		}

		position.Value = values[index]
	}

	return nil
}

// Seek seeks the query to a given cursor
func (pq *ProductQuery) Seek(cursor *ProductCursor) *ProductQuery {
	pq.predicates = append(pq.predicates, pq.seek(cursor.positions))

	for _, position := range cursor.positions {
		switch position.Direction {
		case "+":
			pq.order = append(pq.order, Asc(position.Column))
		case "-":
			pq.order = append(pq.order, Desc(position.Column))
		}
	}

	return pq
}

func (pq *ProductQuery) seek(positions []*CursorPosition) Predicate {
	var (
		predicate        Predicate = func(*sql.Selector) {}
		predicateCompare Predicate = func(*sql.Selector) {}
		predicateEqual   Predicate = func(*sql.Selector) {}
	)

	if len(positions) == 0 {
		return predicate
	}

	position := positions[0]

	if position.Value != nil {
		predicateEqual = EQ(position.Column, position.Value)

		switch position.Direction {
		case "+":
			predicateCompare = GT(position.Column, position.Value)
		case "-":
			predicateCompare = LT(position.Column, position.Value)
		default:
			predicateCompare = GT(position.Column, position.Value)
		}
	}

	positions = positions[1:]
	predicate = predicateCompare

	if len(positions) > 0 {
		predicate = Or(predicateCompare,
			And(predicateEqual, pq.seek(positions)))
	}

	return predicate
}
